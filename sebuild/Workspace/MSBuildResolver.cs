using System.Xml;
using Microsoft.Build.Construction;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.MSBuild;
using MSBuildProjectItem = Microsoft.Build.Evaluation.ProjectItem;
using MSBuildProject = Microsoft.Build.Evaluation.Project;

namespace SeBuild;

/// <summary>
/// Loads MSBuild roslynProject files and adds their source files to a main roslynProject to be processed later.
/// Also resolves NuGet PackageReference tags by downloading their source to a cache directory and 
/// using those source files for compilation
/// </summary>
public sealed class MSBuildResolver: IDisposable {
    /// Script context that contains the roslynProject with flat list of files to add items to
    private ScriptCommon _ctx;

    private MSBuildWorkspace _workspace;

    private PackageCache _remotePackages;

    private HashSet<ProjectId> _localProjects;

    void IDisposable.Dispose() {
        _workspace.Dispose();
    }
    
    /// <summary>
    /// Create a new resolver that will add source files to the given script context
    /// </summary>
    public MSBuildResolver(ScriptCommon ctx, MSBuildWorkspace workspace, string dir) {
        _ctx = ctx;
        _workspace = workspace;
        _remotePackages = new PackageCache(dir);
        _localProjects = new HashSet<ProjectId>();
    }

    public void GetProjectPackages(string projectPath) {
        using var xml = new XmlTextReader(projectPath);
        var root = ProjectRootElement.Create(xml);
        var msProject = new MSBuildProject(root);

        foreach(var packageRef in msProject.GetItems("GitReference")) {
            var repo = packageRef.UnevaluatedInclude; 
            var folder = OptionalMetadata(packageRef, "Folder");
            var host = OptionalMetadata(packageRef, "Host");
            var commit = OptionalMetadata(packageRef, "Commit");
            var state = _remotePackages.GetPackage(
                repo,
                folder,
                commit,
                host
            );
            
            if(state.CsProjPath is not null) {
                GetProjectPackages(state.CsProjPath);
            }
        }
    }

    public async Task AddProjectSources(string projectPath) {
        GetProjectPackages(projectPath);
        var roslynProject = await _workspace.OpenProjectAsync(projectPath);

        foreach(var metaReference in roslynProject.MetadataReferences) {
            if(
                    metaReference.Properties.Kind == MetadataImageKind.Assembly &&
                    !_ctx.Project.MetadataReferences.Contains(metaReference)
                ) {
                _ctx.Solution = _ctx.Project.AddMetadataReference(metaReference).Solution;
            }
        }

        await AddProjectSources(roslynProject);
    }
    
    /// <summary>
    /// Get an optional metadata value from the given project element, returning null if the value is not present.
    /// </summary>
    private string? OptionalMetadata(MSBuildProjectItem element, string name) {
        if(element.HasMetadata(name)) {
            return element.GetMetadataValue(name);
        } else {
            return null;
        }
    }
    
    /// <summary>
    /// Add all sources of the given roslynProject to the script context, and download all 
    /// referenced package sources to a cache directory for later analysis
    /// </summary>
    public async Task AddProjectSources(Project roslynProject) {
        if(_localProjects.Contains(roslynProject.Id)) {
            return;
        }

        _localProjects.Add(roslynProject.Id);

        var ctxProject = _ctx.Project;
        foreach(var doc in roslynProject.Documents) {
            //Skip autogenerated assembly info
            if(doc.Folders.Contains("obj")) {
                continue;
            }
            var syntaxRoot = await doc.GetSyntaxRootAsync();
            if(syntaxRoot is not null) {
                ctxProject = ctxProject.AddDocument(
                    doc.Name,
                    syntaxRoot,
                    doc.Folders,
                    doc.FilePath
                ).Project;
            }
            }

        _ctx.Solution = ctxProject.Solution;

        foreach(var projectReference in roslynProject.ProjectReferences) {
            await AddProjectSources(_workspace.CurrentSolution.GetProject(projectReference.ProjectId)!);
        }
    }
}
