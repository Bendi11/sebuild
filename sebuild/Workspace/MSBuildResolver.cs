using System.Xml;
using Microsoft.Build.Construction;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.MSBuild;
using MSBuildProject = Microsoft.Build.Evaluation.Project;

namespace SeBuild;

/// <summary>
/// Loads MSBuild roslynProject files and adds their source files to a main roslynProject to be processed later.
/// Also resolves NuGet PackageReference tags by downloading their source to a cache directory and 
/// using those source files for compilation
/// </summary>
public sealed class MSBuildResolver: IDisposable {
    /// Script context that contains the roslynProject with flat list of files to add items to
    private ScriptCommon _ctx;

    private MSBuildWorkspace _workspace;

    private HashSet<ProjectId> _processed = new HashSet<ProjectId>();

    void IDisposable.Dispose() {
        _workspace.Dispose();
    }
    
    /// <summary>
    /// Create a new resolver that will add source files to the given script context
    /// </summary>
    public MSBuildResolver(ScriptCommon ctx, MSBuildWorkspace workspace) {
        _ctx = ctx;
        _workspace = workspace;
    }

    public async Task AddProjectSources(string projectPath) {
        var roslynProject = await _workspace.OpenProjectAsync(projectPath);

        using var xml = new XmlTextReader(projectPath);
        var root = ProjectRootElement.Create(xml);
        var msProject = new MSBuildProject(root);
        
        foreach(var metaReference in roslynProject.MetadataReferences) {
            if(metaReference.Properties.Kind == MetadataImageKind.Assembly) {
                _ctx.Solution = _ctx.Project.AddMetadataReference(metaReference).Solution;
            }
        }

        await AddProjectSources(roslynProject);
    }
    
    /// <summary>
    /// Add all sources of the given roslynProject to the script context, and download all 
    /// referenced package sources to a cache directory for later analysis
    /// </summary>
    public async Task AddProjectSources(Project roslynProject) {
        if(_processed.Contains(roslynProject.Id)) {
            return;
        }

        _processed.Add(roslynProject.Id);

        var ctxProject = _ctx.Project;
        foreach(var doc in roslynProject.Documents) {
            //Skip autogenerated assembly info
            if(doc.Folders.Contains("obj")) {
                continue;
            }
            var syntaxRoot = await doc.GetSyntaxRootAsync();
            if(syntaxRoot is not null) {
                ctxProject = ctxProject.AddDocument(
                    doc.Name,
                    syntaxRoot,
                    doc.Folders,
                    doc.FilePath
                ).Project;
            }
        }

        _ctx.Solution = ctxProject.Solution;

        foreach(var projectReference in roslynProject.ProjectReferences) {
            await AddProjectSources(_workspace.CurrentSolution.GetProject(projectReference.ProjectId)!);
        }
    }
}
