using System.IO.Compression;
using System.Net;
using System.Xml;
using LibGit2Sharp;
using Microsoft.Build.Construction;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.MSBuild;
using NuGet.Common;
using NuGet.Configuration;
using NuGet.Packaging;
using NuGet.Protocol;
using NuGet.Protocol.Core.Types;
using NuGet.Versioning;
using MSBuildProject = Microsoft.Build.Evaluation.Project;

namespace SeBuild;

/// <summary>
/// Loads MSBuild roslynProject files and adds their source files to a main roslynProject to be processed later.
/// Also resolves NuGet PackageReference tags by downloading their source to a cache directory and 
/// using those source files for compilation
/// </summary>
public sealed class MSBuildResolver: IDisposable {
    /// Script context that contains the roslynProject with flat list of files to add items to
    private ScriptCommon _ctx;

    private MSBuildWorkspace _workspace;

    private HashSet<ProjectId> _processed = new HashSet<ProjectId>();

    void IDisposable.Dispose() {
        _workspace.Dispose();
    }
    
    /// <summary>
    /// Create a new resolver that will add source files to the given script context
    /// </summary>
    public MSBuildResolver(ScriptCommon ctx, MSBuildWorkspace workspace) {
        _ctx = ctx;
        _workspace = workspace;
    }

    public async Task AddProjectSources(string projectPath) {
        var roslynProject = await _workspace.OpenProjectAsync(projectPath);

        using var xml = new XmlTextReader(projectPath);
        var root = ProjectRootElement.Create(xml);
        var msProject = new MSBuildProject(root);
        
        foreach(var metaReference in roslynProject.MetadataReferences) {
            if(metaReference.Properties.Kind == MetadataImageKind.Assembly) {
                _ctx.Solution = _ctx.Project.AddMetadataReference(metaReference).Solution;
            }
        }

        foreach(var packageRef in msProject.GetItems("GitReference")) {
            var version = packageRef.GetMetadataValue("Tag");
            string? hint = null;
            if(packageRef.HasMetadata("Hint")) {
                hint = packageRef.GetMetadataValue("Hint");
            }
            await AddGitSource(packageRef.EvaluatedInclude, version, hint);
        }

        await AddProjectSources(roslynProject);
    }
    
    /// <summary>
    /// Add all sources of the given roslynProject to the script context, and download all 
    /// referenced package sources to a cache directory for later analysis
    /// </summary>
    public async Task AddProjectSources(Project roslynProject) {
        if(_processed.Contains(roslynProject.Id)) {
            return;
        }

        _processed.Add(roslynProject.Id);

        var ctxProject = _ctx.Project;
        foreach(var doc in roslynProject.Documents) {
            //Skip autogenerated assembly info
            if(doc.Folders.Contains("obj")) {
                continue;
            }
            var syntaxRoot = await doc.GetSyntaxRootAsync();
            if(syntaxRoot is not null) {
                ctxProject = ctxProject.AddDocument(
                    doc.Name,
                    syntaxRoot,
                    doc.Folders,
                    doc.FilePath
                ).Project;
            }
            }

        _ctx.Solution = ctxProject.Solution;

        foreach(var projectReference in roslynProject.ProjectReferences) {
            await AddProjectSources(_workspace.CurrentSolution.GetProject(projectReference.ProjectId)!);
        }
    }
    
    public async Task AddPackageSources(string package, string versionStr, string folderName) {
        SourceRepository repo = Repository.Factory.GetCoreV3("https://api.nuget.org/v3/index.json");
        FindPackageByIdResource findById = await repo.GetResourceAsync<FindPackageByIdResource>();
        NuGetVersion version = new NuGetVersion(versionStr);
        using var packageStream = new MemoryStream();

        await findById
            .CopyNupkgToStreamAsync(
                package,
                version,
                packageStream,
                new SourceCacheContext(),
                NullLogger.Instance,
                CancellationToken.None
            );

        using var reader = new PackageArchiveReader(packageStream);
        var nuspec = await reader.GetNuspecReaderAsync(CancellationToken.None);
        var repository = nuspec.GetRepositoryMetadata();
        
        string folder = "";
        switch(repository.Type) {
            case "git": {
                if(repository.Url is null) {
                    throw new Exception($"No source repository specified for nuget package {package}");
                }
                var url = new Uri(repository.Url);

                using var client = new HttpClient();

                if(url.Host == "github.com") {
                    folder = $"./.sebuild/cache/{repository.Commit}";
                    if(Directory.Exists(folder)) {
                        break;
                    }
                    Directory.CreateDirectory(folder);

                    var zipFile = $"{repository.Url}/archive/{repository.Commit}.zip";
                    using var zipFileStream = await client.GetStreamAsync(zipFile);
                    ZipFile.ExtractToDirectory(zipFileStream, folder);
                }
            } break;

            default: throw new Exception($"Unable to retrieve sources from nuget package {package} with repository type {repository.Type}");
        }

        await AddRemoteSources(Path.Combine(folder, folderName));
    }

    private async Task AddRemoteSources(string folder) {
        foreach(var csProjFile in Directory.GetFiles(folder, "*.cs", SearchOption.AllDirectories)) {
            Console.WriteLine($"Reading {csProjFile}");
            var root = SyntaxFactory.ParseSyntaxTree(await File.ReadAllTextAsync(csProjFile));
            _ctx.Solution = _ctx.Project.AddDocument(
                csProjFile,
                await root.GetRootAsync()
            ).Project.Solution;
        }
    }
}
